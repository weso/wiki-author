{"ast":null,"code":"/*\n* TRIE implementation in Javascript\n* Copyright (c) 2010 Saurabh Odhyan | http://odhyan.com\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n* THE SOFTWARE.\n*\n* Date: Nov 7, 2010\n*/\n\n/*\n* A trie, or prefix tree, is a multi-way tree structure useful for storing strings over an alphabet.\n* It has been used to store large dictionaries of English (say) words in spell-checking programs\n* and in natural-language \"understanding\" programs.\n* @see http://en.wikipedia.org/wiki/Trie\n* @see http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Trie/\n/*\n\n* @class Trie\n* @constructor\n*/\nvar Trie = module.exports = function () {\n  this.words = 0;\n  this.prefixes = 0;\n  this.children = [];\n};\n\nTrie.prototype = {\n  /*\n    * Insert a word into the dictionary.\n    * Recursively traverse through the trie nodes, and create new node if does not already exist.\n    *\n    * @method insert\n    * @param {String} str Word to insert in the dictionary\n    * @param {Integer} pos Current index of the string to be inserted\n    * @return {Void}\n    */\n  insert: function (str, pos) {\n    if (str.length == 0) {\n      //blank string cannot be inserted\n      return;\n    }\n\n    var T = this,\n        k,\n        child;\n\n    if (pos === undefined) {\n      pos = 0;\n    }\n\n    if (pos === str.length) {\n      T.words++;\n      return;\n    }\n\n    T.prefixes++;\n    k = str[pos];\n\n    if (T.children[k] === undefined) {\n      //if node for this char doesn't exist, create one\n      T.children[k] = new Trie();\n    }\n\n    child = T.children[k];\n    child.insert(str, pos + 1);\n  },\n\n  /*\n    * Remove a word from the dictionary.\n    *\n    * @method remove\n    * @param {String} str Word to be removed\n    * @param {Integer} pos Current index of the string to be removed\n    * @return {Void}\n    */\n  remove: function (str, pos) {\n    if (str.length == 0) {\n      return;\n    }\n\n    var T = this,\n        k,\n        child;\n\n    if (pos === undefined) {\n      pos = 0;\n    }\n\n    if (T === undefined) {\n      return;\n    }\n\n    if (pos === str.length) {\n      T.words--;\n      return;\n    }\n\n    T.prefixes--;\n    k = str[pos];\n    child = T.children[k];\n    child.remove(str, pos + 1);\n  },\n\n  /*\n    * Update an existing word in the dictionary.\n    * This method removes the old word from the dictionary and inserts the new word.\n    *\n    * @method update\n    * @param {String} strOld The old word to be replaced\n    * @param {String} strNew The new word to be inserted\n    * @return {Void}\n    */\n  update: function (strOld, strNew) {\n    if (strOld.length == 0 || strNew.length == 0) {\n      return;\n    }\n\n    this.remove(strOld);\n    this.insert(strNew);\n  },\n\n  /*\n    * Count the number of times a given word has been inserted into the dictionary\n    *\n    * @method countWord\n    * @param {String} str Word to get count of\n    * @param {Integer} pos Current index of the given word\n    * @return {Integer} The number of times a given word exists in the dictionary\n    */\n  countWord: function (str, pos) {\n    if (str.length == 0) {\n      return 0;\n    }\n\n    var T = this,\n        k,\n        child,\n        ret = 0;\n\n    if (pos === undefined) {\n      pos = 0;\n    }\n\n    if (pos === str.length) {\n      return T.words;\n    }\n\n    k = str[pos];\n    child = T.children[k];\n\n    if (child !== undefined) {\n      //node exists\n      ret = child.countWord(str, pos + 1);\n    }\n\n    return ret;\n  },\n\n  /*\n    * Count the number of times a given prefix exists in the dictionary\n    *\n    * @method countPrefix\n    * @param {String} str Prefix to get count of\n    * @param {Integer} pos Current index of the given prefix\n    * @return {Integer} The number of times a given prefix exists in the dictionary\n    */\n  countPrefix: function (str, pos) {\n    if (str.length == 0) {\n      return 0;\n    }\n\n    var T = this,\n        k,\n        child,\n        ret = 0;\n\n    if (pos === undefined) {\n      pos = 0;\n    }\n\n    if (pos === str.length) {\n      return T.prefixes;\n    }\n\n    var k = str[pos];\n    child = T.children[k];\n\n    if (child !== undefined) {\n      //node exists\n      ret = child.countPrefix(str, pos + 1);\n    }\n\n    return ret;\n  },\n\n  /*\n    * Find a word in the dictionary\n    *\n    * @method find\n    * @param {String} str The word to find in the dictionary\n    * @return {Boolean} True if the word exists in the dictionary, else false\n    */\n  find: function (str) {\n    if (str.length == 0) {\n      return false;\n    }\n\n    if (this.countWord(str) > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  /*\n    * Get all words in the dictionary\n    *\n    * @method getAllWords\n    * @param {String} str Prefix of current word\n    * @return {Array} Array of words in the dictionary\n    */\n  getAllWords: function (str) {\n    var T = this,\n        k,\n        child,\n        ret = [];\n\n    if (str === undefined) {\n      str = \"\";\n    }\n\n    if (T === undefined) {\n      return [];\n    }\n\n    if (T.words > 0) {\n      ret.push(str);\n    }\n\n    for (k in T.children) {\n      if (T.children.hasOwnProperty(k)) {\n        child = T.children[k];\n        ret = ret.concat(child.getAllWords(str + k));\n      }\n    }\n\n    return ret;\n  },\n\n  /*\n    * Autocomplete a given prefix\n    *\n    * @method autoComplete\n    * @param {String} str Prefix to be completed based on dictionary entries\n    * @param {Integer} pos Current index of the prefix\n    * @return {Array} Array of possible suggestions\n    */\n  autoComplete: function (str, pos) {\n    var T = this,\n        k,\n        child;\n\n    if (str.length == 0) {\n      if (pos === undefined) {\n        return T.getAllWords(str);\n      } else {\n        return [];\n      }\n    }\n\n    if (pos === undefined) {\n      pos = 0;\n    }\n\n    k = str[pos];\n    child = T.children[k];\n\n    if (child === undefined) {\n      //node doesn't exist\n      return [];\n    }\n\n    if (pos === str.length - 1) {\n      return child.getAllWords(str);\n    }\n\n    return child.autoComplete(str, pos + 1);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}