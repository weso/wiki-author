{"ast":null,"code":"import Codemirror from 'codemirror';\nimport Editor from '../entities/editor';\nimport shexUtils from './shexUtils';\nimport Shape from '../entities/shexEntities/shape';\nimport Triple from '../entities/shexEntities/triple';\nimport TypesFactory from '../entities/shexEntities/types/typesFactory';\nimport CardinalityFactory from '../entities/shexEntities/shexUtils/cardinality/cardinalityFactory';\nimport Facet from '../entities/shexEntities/shexUtils/facet';\nimport PrefixedIri from '../entities/shexEntities/types/concreteTypes/prefixedIri';\nimport IriRef from '../entities/shexEntities/types/concreteTypes/iriRef';\nimport BNode from '../entities/shexEntities/types/concreteTypes/bNode';\nimport Primitive from '../entities/shexEntities/types/concreteTypes/primitive';\nimport ValueSet from '../entities/shexEntities/types/concreteTypes/valueSet';\nimport Literal from '../entities/shexEntities/types/concreteTypes/kinds/literal';\nimport NonLiteral from '../entities/shexEntities/types/concreteTypes/kinds/nonLiteral';\nimport IriKind from '../entities/shexEntities/types/concreteTypes/kinds/iriKind';\nimport BNodeKind from '../entities/shexEntities/types/concreteTypes/kinds/bNodeKind';\nimport BlankKind from '../entities/shexEntities/types/concreteTypes/kinds/blankKind';\nimport NumberLiteral from '../entities/shexEntities/types/concreteTypes/literal/numberLiteral';\nimport StringLiteral from '../entities/shexEntities/types/concreteTypes/literal/stringLiteral';\nimport BooleanLiteral from '../entities/shexEntities/types/concreteTypes/literal/booleanLiteral';\nimport Prefix from '../entities/shexEntities/shexUtils/prefix';\nimport ShapeRef from '../entities/shexEntities/shexUtils/shapeRef';\nimport ValueSetValue from '../entities/shexEntities/shexUtils/valueSetValue'; //HAY QUE METER TODOS (Update... igual no hace falta...)\n\nconst PRIMITIVES = ['string', 'integer', 'date', 'boolean'];\nlet refs;\n/**\n*   Obtains all the current tokens in the editor\n*   @return {Array} tokens\n*\n */\n\nfunction getTokens() {\n  let yashe = Editor.getInstance().getYashe();\n  let tokens = [];\n\n  if (yashe != undefined) {\n    for (var l = 0; l < yashe.lineCount(); ++l) {\n      let lineTokens = getNonWsTokens(yashe.getLineTokens(l));\n      lineTokens.forEach(token => {\n        tokens.push(token);\n      });\n    }\n  }\n\n  return tokens;\n}\n/**\n*   Split the tokens into Shapes\n*   @param {Array} Tokens\n*   @return {Array} Defined Shapes (Array of Token's arrays)\n*\n */\n\n\nfunction getDefinedShapes(tokens) {\n  let brackets = 0;\n  let shape = [];\n  let defShapes = [];\n  let shapeCont = 0;\n  let hasTripleStarted = false; //Separate shapes in arrays\n\n  tokens.forEach(element => {\n    //If we find a Shape then we start a new Array of tokens\n    if (element.type == 'shape') {\n      shape = [];\n      shape.push(element);\n      defShapes[shapeCont] = shape;\n      shapeCont++;\n    } else {\n      // IMPORTANT \n      // We could do just shape.push(element) but if there \n      // are directives between shapes we will push that directives into the shape   \n      if (element.string == '{') {\n        hasTripleStarted = true;\n      }\n\n      if (hasTripleStarted) {\n        //Get the tokens while it's from the inside of the shape\n        if (element.string == '{') brackets++;\n        if (element.string == '}') brackets--;\n        if (brackets != 0) shape.push(element); //if(brackets==0)hasTripleStarted = false\n      } else {\n        //Get the previous tokens before the triples\n        shape.push(element);\n      }\n    }\n  });\n  return defShapes;\n}\n/**\n* Get the Shapes objects\n* @param {Array} Shapes (Array of Token's arrays)\n*\n */\n\n\nfunction getShapes(defShapes) {\n  refs = [];\n  let shapes = [];\n  let yashe = Editor.getInstance().getYashe();\n  defShapes.forEach(shape => {\n    let id = shapes.length;\n    let shapeDef = shape[0].string;\n    let shapeType = getType(shapeDef);\n    let qualifier = getQualifier(shape[1]);\n    let triples = getTriples(id, shape);\n    shapes.push(new Shape(id, shapeType, triples, qualifier));\n  });\n  return shapes;\n}\n/**\n* Get the type of the Shape or Triple\n* @param {String} Shape or Triple\n*\n */\n\n\nfunction getType(def) {\n  let value;\n  let yashe = Editor.getInstance().getYashe();\n\n  if (def.startsWith('<')) {\n    value = def.split('<')[1].split('>')[0];\n    return new IriRef(value);\n  } else if (def.startsWith('_:')) {\n    value = def.split(':')[1];\n    return new BNode(value);\n  } else {\n    value = def.split(':')[1];\n    let prefixName = def.split(':')[0];\n    let prefixValue = getPrefixValue(yashe.getDefinedPrefixes(), prefixName);\n    let prefix = new Prefix(prefixName, prefixValue);\n    return new PrefixedIri(prefix, value);\n  }\n}\n/**\n*   Get the Qualifier\n*   @param {Token} First token next to the ShapeExprLabel\n*   @return {Type}\n*\n*/\n\n\nfunction getQualifier(qualifier) {\n  if (qualifier) {\n    if (qualifier.type == 'constraintKeyword') {\n      let type = qualifier.string.toLowerCase();\n      return new TypesFactory().createType(type);\n    }\n  }\n\n  return new BlankKind();\n}\n/**\n*   Get an array of Triples\n*   @param {Integer} shapeId\n*   @param {Array} Shape (Tokens)\n*\n* */\n\n\nfunction getTriples(shapeId, shape) {\n  let triples = [];\n  let singleTriple = [];\n  let yashe = Editor.getInstance().getYashe();\n  let start = getStart(shape);\n\n  for (let i = start; i < shape.length; i++) {\n    singleTriple.push(shape[i]);\n\n    if (shape[i].type == 'punc' && shape[i].string == ';' || // finish of the triple ';' \n    i == shape.length - 1) {\n      // finish of the last triple without ';'\n      if (singleTriple.length != 1) {\n        //This line is neccesary when last triple of the shape ends with ';'\n        triples.push(getTriple(triples.length, singleTriple, shapeId));\n        singleTriple = [];\n      }\n    }\n  }\n\n  return triples;\n}\n/**\n*    Get a Triple Object from a line of tokens\n*    @param {Array} Triples\n*    @param {Array} LineTokens\n*    @param {Integer} ShapeId\n*/\n\n\nfunction getTriple(id, singleTriple, shapeId) {\n  let type;\n  let constraint;\n  let valueSet = [];\n  let facets = [];\n  let cardinality = new TypesFactory().createType('');\n  let shapeRef = new ShapeRef();\n\n  for (let i = 0; i < singleTriple.length; i++) {\n    let token = singleTriple[i];\n\n    if (token.type == 'string-2' || token.type == 'variable-3') {\n      type = getType(token.string);\n    }\n\n    if (token.type == 'constraint' || token.type == 'constraintKeyword') {\n      constraint = getConstraint(token.string);\n    }\n\n    if (token.type == 'valueSet') {\n      if (token.string.startsWith('@')) {\n        // LANTAG NOT SUPPORTED AT THE MOMENT\n        Codemirror.signal(Editor.getInstance().getYashe(), 'forceError', 'LANTAG_ERR');\n      } else {\n        valueSet.push(new ValueSetValue(valueSet.length, getValueSetValue(token.string)));\n      }\n    }\n\n    if (token.type == 'shapeRef') {\n      let ref = getRefName(token.string);\n      refs.push({\n        shapeId: shapeId,\n        tripleId: id,\n        shapeRef: ref\n      });\n    }\n\n    if (token.type == 'facet') {\n      i++; //Need the value\n\n      let value = singleTriple[i].string;\n      let id = facets.length;\n      let type = token.string.toLowerCase();\n      facets.push(new Facet(id, type, value));\n    }\n\n    if (token.type == 'cardinality') {\n      cardinality = getCardinality(token.string);\n    }\n\n    if (token.type != 'string-2' && token.type != 'constraint' && token.type != 'constraintKeyword' && token.type != 'valueSet' && token.type != 'shapeRef' && token.type != 'facet' && token.type != 'cardinality' && token.type != 'punc' && token.type != 'comment') {\n      Codemirror.signal(Editor.getInstance().getYashe(), 'forceError');\n    }\n\n    if (token.string == '~') {\n      Codemirror.signal(Editor.getInstance().getYashe(), 'forceError', 'EXCLUSION_ERR');\n    }\n\n    if (token.string == '{') {\n      Codemirror.signal(Editor.getInstance().getYashe(), 'forceError');\n    }\n  }\n\n  if (valueSet.length > 0) constraint = new ValueSet(valueSet);\n  return new Triple(id, type, constraint, shapeRef, facets, cardinality);\n}\n/**\n*   Get the start of the triple tokens\n*   @param {Array} Shape (Tokens)\n*   @return {Integer} Position\n*\n */\n\n\nfunction getStart(shape) {\n  for (let i = 0; i < shape.length; i++) {\n    if (shape[i].string == '{') {\n      return i + 1;\n    }\n  }\n}\n/**\n*   Get the constraint of the Triple\n*   @param {String} Token\n*   @return {Type}\n*/\n\n\nfunction getConstraint(def) {\n  let factory = new TypesFactory();\n  let type = factory.createType(def.toLowerCase()); //Isn't it a Prefixed/Iri/Primitive?\n\n  if (type != undefined) {\n    return type;\n  }\n\n  type = getType(def); //Is it a Primitive?\n\n  if (type.getTypeName() == 'prefixedIri' && isPrimitive(type.value)) {\n    let kind = def.split(':')[1];\n    return new Primitive(kind);\n  }\n\n  return type;\n}\n/**\n*   Get the Cardinality Object\n*   @param {String} Cardinality\n*   @return {Cardinality|String} Cardinality\n* */\n\n\nfunction getCardinality(card) {\n  let factory = new CardinalityFactory();\n  if (card.length == 1) return factory.createCardinality(card); //Is it a simple card?\n\n  let range = card.split('{')[1].split('}')[0].split(','); //I know...\n\n  let min = range[0];\n  let max;\n\n  if (range.length > 1) {\n    max = range[1];\n  }\n\n  let context = 'range';\n\n  if (max == undefined) {\n    context = 'exactly';\n  }\n\n  if (max == '' || max == '*') {\n    context = 'minLimit';\n  }\n\n  return factory.createCardinality(context, min, max);\n}\n/**\n* Get the type of a valueSetValue\n* @param {String} Token\n* @return {Type} ValueSetValue\n*\n */\n\n\nfunction getValueSetValue(def) {\n  if (!isNaN(def)) {\n    return new NumberLiteral(def);\n  }\n\n  if (def.startsWith('\"')) {\n    return new StringLiteral(def.substring(1, def.length - 1)); //remove the \"\"\n  }\n\n  let minus = def.toLowerCase();\n\n  if (minus == 'true' || minus == 'false') {\n    return new BooleanLiteral(minus);\n  }\n\n  return getType(def);\n}\n\nfunction updateShapeRefs(shapes) {\n  for (let r in refs) {\n    let shapeId = refs[r].shapeId;\n    let tripleId = refs[r].tripleId;\n    let ref = refs[r].shapeRef;\n    let shape = shexUtils.getShapeById(shapes, shapeId);\n    let triple = shexUtils.getTripleById(shape, tripleId);\n    let shapeRef = shexUtils.getShapeByName(shapes, ref);\n    triple.shapeRef.setShape(shapeRef);\n  }\n}\n\nfunction getPrefixValue(defPrefixes, prefixName) {\n  let prefixValue;\n\n  for (let pre in defPrefixes) {\n    if (pre == prefixName) {\n      prefixValue = defPrefixes[pre];\n    }\n  }\n\n  return prefixValue;\n}\n\nfunction isPrimitive(value) {\n  for (let prim in PRIMITIVES) {\n    if (PRIMITIVES[prim] == value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getRefName(token) {\n  return token.split('@')[1];\n}\n\nfunction getNonWsTokens(tokens) {\n  return tokens.filter(function (obj) {\n    return obj.type != 'ws';\n  });\n}\n\nconst tokenUtils = {\n  getTokens: getTokens,\n  getDefinedShapes: getDefinedShapes,\n  getShapes: getShapes,\n  updateShapeRefs: updateShapeRefs\n};\nexport default tokenUtils;","map":{"version":3,"sources":["/home/mistermboy/repositories/wiki-author/src/utils/tokenUtils.js"],"names":["Codemirror","Editor","shexUtils","Shape","Triple","TypesFactory","CardinalityFactory","Facet","PrefixedIri","IriRef","BNode","Primitive","ValueSet","Literal","NonLiteral","IriKind","BNodeKind","BlankKind","NumberLiteral","StringLiteral","BooleanLiteral","Prefix","ShapeRef","ValueSetValue","PRIMITIVES","refs","getTokens","yashe","getInstance","getYashe","tokens","undefined","l","lineCount","lineTokens","getNonWsTokens","getLineTokens","forEach","token","push","getDefinedShapes","brackets","shape","defShapes","shapeCont","hasTripleStarted","element","type","string","getShapes","shapes","id","length","shapeDef","shapeType","getType","qualifier","getQualifier","triples","getTriples","def","value","startsWith","split","prefixName","prefixValue","getPrefixValue","getDefinedPrefixes","prefix","toLowerCase","createType","shapeId","singleTriple","start","getStart","i","getTriple","constraint","valueSet","facets","cardinality","shapeRef","getConstraint","signal","getValueSetValue","ref","getRefName","tripleId","getCardinality","factory","getTypeName","isPrimitive","kind","card","createCardinality","range","min","max","context","isNaN","substring","minus","updateShapeRefs","r","getShapeById","triple","getTripleById","getShapeByName","setShape","defPrefixes","pre","prim","filter","obj","tokenUtils"],"mappings":"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","sourcesContent":["\nimport Codemirror from 'codemirror';\nimport Editor from '../entities/editor';\nimport shexUtils from './shexUtils';\n\nimport  Shape from '../entities/shexEntities/shape';\nimport  Triple from '../entities/shexEntities/triple';\n\nimport TypesFactory from '../entities/shexEntities/types/typesFactory';\nimport CardinalityFactory from '../entities/shexEntities/shexUtils/cardinality/cardinalityFactory';\nimport Facet from '../entities/shexEntities/shexUtils/facet';\n\nimport PrefixedIri from '../entities/shexEntities/types/concreteTypes/prefixedIri';\nimport IriRef from '../entities/shexEntities/types/concreteTypes/iriRef';\nimport BNode from '../entities/shexEntities/types/concreteTypes/bNode';\nimport Primitive from '../entities/shexEntities/types/concreteTypes/primitive';\nimport ValueSet from '../entities/shexEntities/types/concreteTypes/valueSet';\n\nimport Literal from '../entities/shexEntities/types/concreteTypes/kinds/literal';\nimport NonLiteral from '../entities/shexEntities/types/concreteTypes/kinds/nonLiteral';\nimport IriKind from '../entities/shexEntities/types/concreteTypes/kinds/iriKind';\nimport BNodeKind from '../entities/shexEntities/types/concreteTypes/kinds/bNodeKind';\nimport BlankKind from '../entities/shexEntities/types/concreteTypes/kinds/blankKind';\n\nimport NumberLiteral from '../entities/shexEntities/types/concreteTypes/literal/numberLiteral';\nimport StringLiteral from '../entities/shexEntities/types/concreteTypes/literal/stringLiteral';\nimport BooleanLiteral from '../entities/shexEntities/types/concreteTypes/literal/booleanLiteral';\n\n\n\nimport Prefix from '../entities/shexEntities/shexUtils/prefix';\nimport ShapeRef from '../entities/shexEntities/shexUtils/shapeRef';\nimport ValueSetValue from '../entities/shexEntities/shexUtils/valueSetValue';\n\n\n\n//HAY QUE METER TODOS (Update... igual no hace falta...)\nconst PRIMITIVES = ['string','integer','date','boolean'];\n\n\nlet refs;\n/**\n*   Obtains all the current tokens in the editor\n*   @return {Array} tokens\n*\n */\nfunction getTokens(){\n    let yashe = Editor.getInstance().getYashe();\n    let tokens =[];\n    if(yashe!=undefined){\n        for (var l = 0; l < yashe.lineCount(); ++l) {\n            let lineTokens = getNonWsTokens(yashe.getLineTokens(l));\n            lineTokens.forEach(token =>{\n                tokens.push(token);\n            })\n\n        }\n    }\n    return tokens;\n}\n\n/**\n*   Split the tokens into Shapes\n*   @param {Array} Tokens\n*   @return {Array} Defined Shapes (Array of Token's arrays)\n*\n */\nfunction getDefinedShapes(tokens){\n    let brackets=0\n    let shape=[];\n    let defShapes = [];\n    let shapeCont = 0;\n    let hasTripleStarted = false;\n    //Separate shapes in arrays\n    tokens.forEach(element =>{\n        //If we find a Shape then we start a new Array of tokens\n        if(element.type == 'shape'){\n            shape = [];\n            shape.push(element)\n            defShapes[shapeCont]=shape;\n            shapeCont++;\n        }else{\n            // IMPORTANT \n            // We could do just shape.push(element) but if there \n            // are directives between shapes we will push that directives into the shape   \n\n            if(element.string == '{'){\n                hasTripleStarted=true;\n            }\n             \n            if(hasTripleStarted){\n                //Get the tokens while it's from the inside of the shape\n                if(element.string == '{')brackets++;\n                if(element.string == '}')brackets--;\n                if(brackets!=0)shape.push(element);\n                //if(brackets==0)hasTripleStarted = false\n             }else{\n                 //Get the previous tokens before the triples\n                 shape.push(element);\n             }\n       \n        }\n    })\n    return defShapes;\n}\n\n/**\n* Get the Shapes objects\n* @param {Array} Shapes (Array of Token's arrays)\n*\n */\nfunction getShapes(defShapes){\n    refs = [];\n    let shapes = [];\n    let yashe = Editor.getInstance().getYashe();\n    defShapes.forEach(shape => {\n        let id  = shapes.length;\n        let shapeDef = shape[0].string;\n        let shapeType = getType(shapeDef);\n        let qualifier = getQualifier(shape[1]);\n        let triples = getTriples(id,shape);\n\n        shapes.push(new Shape(id,shapeType,triples,qualifier));\n    })\n    return shapes;\n}\n\n/**\n* Get the type of the Shape or Triple\n* @param {String} Shape or Triple\n*\n */\nfunction getType(def) {\n    let value;\n    let yashe = Editor.getInstance().getYashe();\n    if(def.startsWith('<')){\n        value = def.split('<')[1].split('>')[0];\n        return new IriRef(value);\n    }else if(def.startsWith('_:')){\n        value = def.split(':')[1];\n        return new BNode(value);\n    }else{\n        value = def.split(':')[1];\n        let prefixName = def.split(':')[0];\n        let prefixValue = getPrefixValue(yashe.getDefinedPrefixes(),prefixName)\n        let prefix = new Prefix(prefixName,prefixValue);\n        return new PrefixedIri(prefix,value);\n    }\n}\n\n\n/**\n*   Get the Qualifier\n*   @param {Token} First token next to the ShapeExprLabel\n*   @return {Type}\n*\n*/\nfunction getQualifier(qualifier) {\n    if(qualifier){\n        if(qualifier.type == 'constraintKeyword'){\n            let type = qualifier.string.toLowerCase();\n            return new TypesFactory().createType(type);\n        }\n    }\n    return new BlankKind();\n}\n\n\n/**\n*   Get an array of Triples\n*   @param {Integer} shapeId\n*   @param {Array} Shape (Tokens)\n*\n* */\nfunction getTriples(shapeId,shape) {\n        let triples = [];\n        let singleTriple = [];\n        let yashe = Editor.getInstance().getYashe();\n        let start = getStart(shape);\n        for(let i=start;i<shape.length;i++){\n            singleTriple.push(shape[i])\n            if((shape[i].type == 'punc' &&  shape[i].string==';')// finish of the triple ';' \n                || i==shape.length-1){  // finish of the last triple without ';'\n                if(singleTriple.length!=1){ //This line is neccesary when last triple of the shape ends with ';'\n                    triples.push(getTriple(triples.length,singleTriple,shapeId));\n                    singleTriple = [];\n                }\n            }\n\n        }\n    return triples;\n}\n\n/**\n*    Get a Triple Object from a line of tokens\n*    @param {Array} Triples\n*    @param {Array} LineTokens\n*    @param {Integer} ShapeId\n*/\nfunction getTriple(id,singleTriple,shapeId) {   \n    let type;\n    let constraint;\n    let valueSet = [];\n    let facets = [];\n    let cardinality= new TypesFactory().createType('');\n    let shapeRef = new ShapeRef();\n    for(let i=0;i<singleTriple.length;i++){\n        let token = singleTriple[i];\n        if(token.type == 'string-2' || token.type == 'variable-3'){\n            type = getType(token.string);\n        }\n        if(token.type == 'constraint' || token.type == 'constraintKeyword' ){\n            constraint = getConstraint(token.string);\n        }\n        \n\n        if(token.type == 'valueSet'){\n            if(token.string.startsWith('@')){// LANTAG NOT SUPPORTED AT THE MOMENT\n                Codemirror.signal(Editor.getInstance().getYashe(),'forceError','LANTAG_ERR');\n            }else{\n                 valueSet.push(new ValueSetValue(valueSet.length,getValueSetValue(token.string)));\n            }\n        }\n\n        if(token.type == 'shapeRef' ){\n            let ref = getRefName(token.string);\n            refs.push(\n                    {\n                        shapeId:shapeId,\n                        tripleId:id,\n                        shapeRef:ref\n                    }\n                );\n        }\n\n        if(token.type == 'facet'){\n            i++;//Need the value\n            let value = singleTriple[i].string;\n            let id =facets.length;\n            let type = token.string.toLowerCase();\n            facets.push(new Facet(id,type,value));\n        }\n\n\n        if(token.type == 'cardinality'){\n          cardinality=getCardinality(token.string);\n        }\n        \n        if( token.type != 'string-2' && \n            token.type != 'constraint' && \n            token.type != 'constraintKeyword' && \n            token.type != 'valueSet' && \n            token.type != 'shapeRef' && \n            token.type != 'facet' && \n            token.type != 'cardinality' && \n            token.type != 'punc' &&\n            token.type !='comment'){\n\n            Codemirror.signal(Editor.getInstance().getYashe(),'forceError');\n        }\n\n       \n        if(token.string == '~'){\n            Codemirror.signal(Editor.getInstance().getYashe(),'forceError','EXCLUSION_ERR');\n        }\n            \n\n        if(token.string == '{'){\n            Codemirror.signal(Editor.getInstance().getYashe(),'forceError');\n        }\n  \n    }\n    if(valueSet.length>0)constraint=new ValueSet(valueSet);\n    return new Triple(id,type,constraint,shapeRef,facets,cardinality);\n}\n\n/**\n*   Get the start of the triple tokens\n*   @param {Array} Shape (Tokens)\n*   @return {Integer} Position\n*\n */\nfunction getStart(shape){\n    for(let i=0;i<shape.length;i++){\n        if(shape[i].string=='{'){\n            return i+1;\n        }\n    }\n}\n\n\n/**\n*   Get the constraint of the Triple\n*   @param {String} Token\n*   @return {Type}\n*/\nfunction getConstraint(def) {\n    let factory = new TypesFactory();\n    let type = factory.createType(def.toLowerCase());\n    //Isn't it a Prefixed/Iri/Primitive?\n    if(type!=undefined){\n        return type;\n    }\n    type = getType(def);\n    //Is it a Primitive?\n    if(type.getTypeName() == 'prefixedIri' && isPrimitive(type.value)){\n        let kind = def.split(':')[1];\n        return new Primitive(kind);\n    }\n    return type;\n}\n\n\n/**\n*   Get the Cardinality Object\n*   @param {String} Cardinality\n*   @return {Cardinality|String} Cardinality\n* */\nfunction getCardinality(card){\n    let factory = new CardinalityFactory();\n    if(card.length==1)return factory.createCardinality(card);//Is it a simple card?\n    let range = card.split('{')[1].split('}')[0].split(','); //I know...\n    let min = range[0];\n    let max;\n    if(range.length>1){\n        max = range[1];\n    }\n\n    let context = 'range';\n    if(max == undefined){\n        context = 'exactly';\n    }\n    if(max == '' || max == '*'){\n        context = 'minLimit';\n    }\n\n    return factory.createCardinality(context,min,max);\n}\n\n\n/**\n* Get the type of a valueSetValue\n* @param {String} Token\n* @return {Type} ValueSetValue\n*\n */\nfunction getValueSetValue(def) {\n\n    if(!isNaN(def)){\n        return new NumberLiteral(def);\n    }\n\n    if(def.startsWith('\"')){\n        return new StringLiteral(def.substring(1,def.length-1));//remove the \"\"\n    }\n\n    let minus = def.toLowerCase();\n    if(minus == 'true' || minus == 'false'){\n        return new BooleanLiteral(minus);\n    }\n\n    return getType(def);\n}\n\n\n\n\n\nfunction updateShapeRefs(shapes) {\n    for(let r in refs){\n        let shapeId = refs[r].shapeId;\n        let tripleId = refs[r].tripleId;\n        let ref = refs[r].shapeRef;\n\n        let shape = shexUtils.getShapeById(shapes,shapeId);\n        let triple = shexUtils.getTripleById(shape,tripleId);\n        let shapeRef = shexUtils.getShapeByName(shapes,ref);\n\n        triple.shapeRef.setShape(shapeRef);\n    }\n}\n\n\n\n\n\nfunction getPrefixValue(defPrefixes,prefixName){\n    let prefixValue;\n    for(let pre in defPrefixes){\n        if(pre==prefixName){\n            prefixValue = defPrefixes[pre]\n        }\n    }\n    return prefixValue;\n}\n\n\nfunction isPrimitive(value) {\n    for(let prim in PRIMITIVES){\n        if(PRIMITIVES[prim] == value){\n            return true;\n        }\n    }\n    return false;\n}\n\n\nfunction getRefName(token) {\n    return token.split('@')[1];\n}\n\n\nfunction getNonWsTokens(tokens){\n    return tokens.filter(function(obj){\n        return obj.type != 'ws';\n    })\n}\n\nconst tokenUtils = {\n    getTokens:getTokens,\n    getDefinedShapes:getDefinedShapes,\n    getShapes:getShapes,\n    updateShapeRefs:updateShapeRefs\n}\n\nexport default tokenUtils;"]},"metadata":{},"sourceType":"module"}