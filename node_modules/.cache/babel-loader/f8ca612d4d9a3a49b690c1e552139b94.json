{"ast":null,"code":"\"use strict\";\n\nvar $ = require(\"jquery\"); //this is a mapping from the class names (generic ones, for compatability with codemirror themes), to what they -actually- represent\n\n\nvar tokenTypes = {\n  \"string-2\": \"prefixed\",\n  atom: \"var\"\n};\n\nmodule.exports = function (yashe, completerName) {\n  //this autocompleter also fires on-change!\n  yashe.on(\"change\", function () {\n    module.exports.appendPrefixIfNeeded(yashe, completerName);\n  });\n  return {\n    isValidCompletionPosition: function () {\n      return module.exports.isValidCompletionPosition(yashe);\n    },\n    get: function (token, callback) {\n      $.get(module.exports.fetchFrom, function (data) {\n        var prefixArray = [];\n\n        for (var prefix in data) {\n          if (prefix == \"bif\") continue; // skip this one! see #231\n\n          var completeString = prefix + \": <\" + data[prefix] + \">\";\n          prefixArray.push(completeString); // the array we want to store in localstorage\n        }\n\n        prefixArray.sort();\n        callback(prefixArray);\n      });\n    },\n    preProcessToken: function (token) {\n      return module.exports.preprocessPrefixTokenForCompletion(yashe, token);\n    },\n    async: true,\n    bulk: true,\n    autoShow: true,\n    persistent: completerName,\n    callbacks: {\n      pick: function () {\n        yashe.collapsePrefixes(false);\n      }\n    }\n  };\n};\n\nmodule.exports.isValidCompletionPosition = function (yashe) {\n  var cur = yashe.getCursor(),\n      token = yashe.getTokenAt(cur); // not at end of line\n\n  if (yashe.getLine(cur.line).length > cur.ch) return false;\n\n  if (token.type != \"ws\") {\n    // we want to complete token, e.g. when the prefix starts with an a\n    // (treated as a token in itself..)\n    // but we to avoid including the PREFIX tag. So when we have just\n    // typed a space after the prefix tag, don't get the complete token\n    token = yashe.getCompleteToken();\n  } // we shouldnt be at the uri part the prefix declaration\n  // also check whether current token isnt 'a' (that makes codemirror\n  // thing a namespace is a possiblecurrent\n\n\n  if (!token.string.indexOf(\"a\") == 0 && $.inArray(\"PNAME_NS\", token.state.possibleCurrent) == -1) return false; // First token of line needs to be PREFIX,\n  // there should be no trailing text (otherwise, text is wrongly inserted\n  // in between)\n\n  var previousToken = yashe.getPreviousNonWsToken(cur.line, token);\n  if (!previousToken || previousToken.string.toUpperCase() != \"PREFIX\") return false;\n  return true;\n};\n\nmodule.exports.preprocessPrefixTokenForCompletion = function (yashe, token) {\n  var previousToken = yashe.getPreviousNonWsToken(yashe.getCursor().line, token);\n\n  if (previousToken && previousToken.string && previousToken.string.slice(-1) == \":\") {\n    //combine both tokens! In this case we have the cursor at the end of line \"PREFIX bla: <\".\n    //we want the token to be \"bla: <\", en not \"<\"\n    token = {\n      start: previousToken.start,\n      end: token.end,\n      string: previousToken.string + \" \" + token.string,\n      state: token.state\n    };\n  }\n\n  return token;\n};\n/**\n * Check whether typed prefix is declared. If not, automatically add declaration\n * using list from prefix.cc\n *\n * @param yashe\n */\n\n\nmodule.exports.appendPrefixIfNeeded = function (yashe, completerName) {\n  if (!yashe.autocompleters.getTrie(completerName)) return; // no prefixed defined. just stop\n\n  if (!yashe.options.autocompleters || yashe.options.autocompleters.indexOf(completerName) == -1) return; //this autocompleter is disabled\n\n  var cur = yashe.getCursor();\n  var token = yashe.getTokenAt(cur);\n\n  if (tokenTypes[token.type] == \"prefixed\") {\n    var colonIndex = token.string.indexOf(\":\");\n\n    if (colonIndex !== -1) {\n      // check previous token isnt PREFIX, or a '<'(which would mean we are in a uri)\n      //\t\t\tvar firstTokenString = yashe.getNextNonWsToken(cur.line).string.toUpperCase();\n      var lastNonWsTokenString = yashe.getPreviousNonWsToken(cur.line, token).string.toUpperCase();\n      var previousToken = yashe.getTokenAt({\n        line: cur.line,\n        ch: token.start\n      }); // needs to be null (beginning of line), or whitespace\n\n      if (lastNonWsTokenString != \"PREFIX\" && (previousToken.type == \"ws\" || previousToken.type == null)) {\n        // check whether it isnt defined already (saves us from looping\n        // through the array)\n        var currentPrefix = token.string.substring(0, colonIndex + 1);\n        var queryPrefixes = yashe.getDefinedPrefixes();\n\n        if (queryPrefixes[currentPrefix.slice(0, -1)] == null) {\n          // ok, so it isnt added yet!\n          var completions = yashe.autocompleters.getTrie(completerName).autoComplete(currentPrefix);\n\n          if (completions.length > 0) {\n            yashe.addPrefixes(completions[0]);\n          }\n        }\n      }\n    }\n  }\n};\n\nmodule.exports.fetchFrom = (window.location.protocol.indexOf(\"http\") === 0 ? \"//\" : \"http://\") + \"prefix.cc/popular/all.file.json\";","map":null,"metadata":{},"sourceType":"script"}