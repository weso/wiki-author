{"ast":null,"code":"import Codemirror from 'codemirror';\nimport Editor from '../entities/editor';\nimport Prefix from '../entities/shexEntities/shexUtils/prefix';\nimport { ALL_PREFIXES } from './rdfUtils';\nlet prefixCount = 0;\nexport function getPrefix(prefix) {\n  let defined = Editor.getInstance().getYashe().getDefinedPrefixes();\n\n  for (let def in defined) {\n    if (defined[def] == prefix) {\n      return new Prefix(def, defined[def]);\n    }\n  }\n\n  return new Prefix();\n}\nexport function addPrefixComp(prefixes, width) {\n  const id = prefixes.length + prefixCount++;\n  let newPrefix = new Prefix('', '', id);\n  let newPrefixes = [];\n  newPrefixes = Object.assign(newPrefixes, prefixes);\n  newPrefixes.push(newPrefix);\n  emitPrefixes(newPrefixes, width);\n  return newPrefix;\n}\nexport function deletePrefixComp(prefixes, prefixId, width) {\n  let newPrefixes = prefixes.filter(prefix => prefix.id != prefixId);\n  emitPrefixes(newPrefixes, width);\n  return newPrefixes;\n}\nexport function addPrefix(prefix) {\n  let namespaces = ALL_PREFIXES;\n  let yashe = Editor.getInstance().getYashe();\n  let current = yashe.getValue();\n  let defined = yashe.getDefinedPrefixes();\n  let uri = 'http://example.org/'; //getUri\n\n  for (let def in namespaces) {\n    for (let p in namespaces[def]) {\n      if (p == prefix) uri = namespaces[def][p];\n    }\n  }\n\n  yashe.setValue('PREFIX ' + prefix + ': <' + uri + '>\\n' + current);\n  Codemirror.signal(yashe, 'prefixUpdate');\n}\nexport function getUri(prefix, namespaces) {\n  for (let def in namespaces) {\n    for (let p in namespaces[def]) {\n      if (p == prefix) return namespaces[def][p];\n    }\n  }\n\n  return 'http://example.org/';\n}\n\nfunction getPrefixesStr(prefixes) {\n  let str = '';\n  prefixes.map(prefix => {\n    str += 'PREFIX ' + prefix.prefixName + ': <' + prefix.prefixValue + '>\\n';\n  });\n  return str;\n}\n\nexport function emitPrefixes(newPrefixes, width) {\n  const yashe = Editor.getInstance().getYashe();\n\n  if (yashe != undefined) {\n    Codemirror.signal(yashe, 'prefixChange', getPrefixesStr(newPrefixes), width);\n  }\n}","map":{"version":3,"sources":["/home/mistermboy/repositories/wiki-author/src/utils/prefixUtils.js"],"names":["Codemirror","Editor","Prefix","ALL_PREFIXES","prefixCount","getPrefix","prefix","defined","getInstance","getYashe","getDefinedPrefixes","def","addPrefixComp","prefixes","width","id","length","newPrefix","newPrefixes","Object","assign","push","emitPrefixes","deletePrefixComp","prefixId","filter","addPrefix","namespaces","yashe","current","getValue","uri","p","setValue","signal","getUri","getPrefixesStr","str","map","prefixName","prefixValue","undefined"],"mappings":"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","sourcesContent":["import Codemirror from 'codemirror';\nimport Editor from '../entities/editor';\nimport Prefix from '../entities/shexEntities/shexUtils/prefix';\nimport {ALL_PREFIXES} from './rdfUtils';\n\nlet prefixCount = 0;\n\nexport function getPrefix(prefix){\n    let defined = Editor.getInstance().getYashe().getDefinedPrefixes();\n    for(let def in defined){\n        if(defined[def] == prefix){\n          return new Prefix(def,defined[def]);\n        }\n    }\n    return new Prefix();\n}\n\n\n\nexport function addPrefixComp(prefixes,width){\n    const id = prefixes.length + prefixCount++;\n    let newPrefix = new Prefix('','',id);\n    let newPrefixes = [];\n    newPrefixes = Object.assign(newPrefixes, prefixes);\n    newPrefixes.push(newPrefix);\n    emitPrefixes(newPrefixes,width);\n    return newPrefix;\n}\n\nexport function deletePrefixComp(prefixes,prefixId,width) {\n    let newPrefixes = prefixes.filter(prefix => prefix.id != prefixId);\n    emitPrefixes(newPrefixes,width);\n    return newPrefixes;\n}\n\n\nexport function addPrefix(prefix){\n        let namespaces = ALL_PREFIXES;\n        let yashe = Editor.getInstance().getYashe();\n        let current = yashe.getValue();\n        let defined = yashe.getDefinedPrefixes();\n        let uri = 'http://example.org/';\n        //getUri\n        for(let def in namespaces){\n          for(let p in namespaces[def]){\n            if(p==prefix)\n              uri = namespaces[def][p];\n          }\n        }\n        yashe.setValue( 'PREFIX ' + prefix + ': <' + uri + '>\\n' + current );\n        Codemirror.signal(yashe,'prefixUpdate');\n  }\n\n\nexport function getUri(prefix,namespaces){\n  for(let def in namespaces){\n    for(let p in namespaces[def]){\n      if(p==prefix)\n        return namespaces[def][p];\n    }\n  }\n  return 'http://example.org/';\n}\n\n\nfunction getPrefixesStr(prefixes){\n  let str='';\n  prefixes.map(prefix =>{\n    str += 'PREFIX ' + prefix.prefixName + ': <' + prefix.prefixValue + '>\\n';\n  })\n  return str;\n}\n\nexport function emitPrefixes(newPrefixes,width) {\n    const yashe = Editor.getInstance().getYashe();\n    if(yashe!=undefined){\n        Codemirror.signal(yashe,'prefixChange',getPrefixesStr(newPrefixes),width);\n    }\n}"]},"metadata":{},"sourceType":"module"}