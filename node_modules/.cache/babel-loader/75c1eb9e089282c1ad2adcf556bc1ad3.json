{"ast":null,"code":"\"use strict\";\n\nvar $ = require(\"jquery\"),\n    utils = require(\"../utils/baseUtils.js\"),\n    yutils = require(\"yasgui-utils\"),\n    Trie = require(\"../../lib/trie.js\"),\n    YASHE = require(\"../main.js\");\n\nmodule.exports = function (YASHE, yashe) {\n  var completionNotifications = {};\n  var completers = {};\n  var tries = {};\n  yashe.on(\"cursorActivity\", function (yashe, eventInfo) {\n    autoComplete(true);\n  });\n  yashe.on(\"change\", function () {\n    var needPossibleAdjustment = [];\n\n    for (var notificationName in completionNotifications) {\n      if (completionNotifications[notificationName].is(\":visible\")) {\n        needPossibleAdjustment.push(completionNotifications[notificationName]);\n      }\n    }\n\n    if (needPossibleAdjustment.length > 0) {\n      //position completion notifications\n      var scrollBar = $(yashe.getWrapperElement()).find(\".CodeMirror-vscrollbar\");\n      var offset = 0;\n\n      if (scrollBar.is(\":visible\")) {\n        offset = scrollBar.outerWidth();\n      }\n\n      needPossibleAdjustment.forEach(function (notification) {\n        notification.css(\"right\", offset);\n      });\n    }\n  });\n  /**\n  * Store bulk completions in memory as trie, and store these in localstorage as well (if enabled)\n  *\n  * @method doc.storeBulkCompletions\n  * @param completions {array}\n  */\n\n  var storeBulkCompletions = function (completer, completions) {\n    // store array as trie\n    tries[completer.name] = new Trie();\n\n    for (var i = 0; i < completions.length; i++) {\n      tries[completer.name].insert(completions[i]);\n    } // store in localstorage as well\n\n\n    var storageId = utils.getPersistencyId(yashe, completer.persistent);\n    if (storageId) yutils.storage.set(storageId, completions, \"month\", yashe.options.onQuotaExceeded);\n  };\n\n  var initCompleter = function (name, completionInit) {\n    var completer = completers[name] = new completionInit(yashe, name);\n    completer.name = name;\n\n    if (completer.bulk) {\n      var storeArrayAsBulk = function (suggestions) {\n        if (suggestions && suggestions instanceof Array && suggestions.length > 0) {\n          storeBulkCompletions(completer, suggestions);\n        }\n      };\n\n      if (completer.get instanceof Array) {\n        // we don't care whether the completions are already stored in\n        // localstorage. just use this one\n        storeArrayAsBulk(completer.get);\n      } else {\n        // if completions are defined in localstorage, use those! (calling the\n        // function may come with overhead (e.g. async calls))\n        var completionsFromStorage = null;\n        var persistencyIdentifier = utils.getPersistencyId(yashe, completer.persistent);\n        if (persistencyIdentifier) completionsFromStorage = yutils.storage.get(persistencyIdentifier);\n\n        if (completionsFromStorage && completionsFromStorage.length > 0) {\n          storeArrayAsBulk(completionsFromStorage);\n        } else {\n          // nothing in storage. check whether we have a function via which we\n          // can get our prefixes\n          if (completer.get instanceof Function) {\n            if (completer.async) {\n              completer.get(null, storeArrayAsBulk);\n            } else {\n              storeArrayAsBulk(completer.get());\n            }\n          }\n        }\n      }\n    }\n  };\n\n  var autoComplete = function (fromAutoShow) {\n    if (yashe.somethingSelected()) return;\n\n    var tryHintType = function (completer) {\n      if (fromAutoShow && ( // from autoShow, i.e. this gets called each time the editor content changes\n      !completer.autoShow || // autoshow for  this particular type of autocompletion is -not- enabled\n      !completer.bulk && completer.async) // async is enabled (don't want to re-do ajax-like request for every editor change)\n      ) {\n          return false;\n        }\n\n      var hintConfig = {\n        closeCharacters: /(?=a)b/,\n        completeSingle: false\n      };\n\n      if (!completer.bulk && completer.async) {\n        hintConfig.async = true;\n      }\n\n      var wrappedHintCallback = function (yashe, callback) {\n        return getCompletionHintsObject(completer, callback);\n      };\n\n      var result = YASHE.showHint(yashe, wrappedHintCallback, hintConfig);\n      return true;\n    };\n\n    for (var completerName in completers) {\n      if ($.inArray(completerName, yashe.options.autocompleters) == -1) continue; //this completer is disabled\n\n      var completer = completers[completerName];\n      if (!completer.isValidCompletionPosition) continue; //no way to check whether we are in a valid position\n\n      if (!completer.isValidCompletionPosition()) {\n        //if needed, fire callbacks for when we are -not- in valid completion position\n        if (completer.callbacks && completer.callbacks.invalidPosition) {\n          completer.callbacks.invalidPosition(yashe, completer);\n        } //not in a valid position, so continue to next completion candidate type\n\n\n        continue;\n      } // run valid position handler, if there is one (if it returns false, stop the autocompletion!)\n\n\n      if (completer.callbacks && completer.callbacks.validPosition) {\n        if (completer.callbacks.validPosition(yashe, completer) === false) continue;\n      }\n\n      var success = tryHintType(completer);\n      if (success) break;\n    }\n  };\n\n  var getCompletionHintsObject = function (completer, callback) {\n    var getSuggestionsFromToken = function (partialToken) {\n      var stringToAutocomplete = partialToken.autocompletionString || partialToken.string;\n      var suggestions = [];\n\n      if (tries[completer.name]) {\n        suggestions = tries[completer.name].autoComplete(stringToAutocomplete);\n      } else if (typeof completer.get == \"function\" && completer.async == false) {\n        suggestions = completer.get(stringToAutocomplete);\n      } else if (typeof completer.get == \"object\") {\n        var partialTokenLength = stringToAutocomplete.length;\n\n        for (var i = 0; i < completer.get.length; i++) {\n          var completion = completer.get[i];\n\n          if (completion.slice(0, partialTokenLength) == stringToAutocomplete) {\n            suggestions.push(completion);\n          }\n        }\n      }\n\n      return getSuggestionsAsHintObject(suggestions, completer, partialToken);\n    };\n\n    var token = yashe.getCompleteToken();\n\n    if (completer.preProcessToken) {\n      token = completer.preProcessToken(token);\n    }\n\n    if (token) {\n      // use custom completionhint function, to avoid reaching a loop when the\n      // completionhint is the same as the current token\n      // regular behaviour would keep changing the codemirror dom, hence\n      // constantly calling this callback\n      if (!completer.bulk && completer.async) {\n        var wrappedCallback = function (suggestions) {\n          callback(getSuggestionsAsHintObject(suggestions, completer, token));\n        };\n\n        completer.get(token, wrappedCallback);\n      } else {\n        return getSuggestionsFromToken(token);\n      }\n    }\n  };\n  /**\n  *  get our array of suggestions (strings) in the codemirror hint format\n  */\n\n\n  var getSuggestionsAsHintObject = function (suggestions, completer, token) {\n    var hintList = [];\n    var startChar; //For the wikidata completer we recive the {text, displayText} object\n\n    if (completer.name == 'wikidata' || completer.name == 'prefixesAndKeywords') {\n      for (var i = 0; i < suggestions.length; i++) {\n        hintList.push({\n          text: suggestions[i].text,\n          displayText: suggestions[i].displayText,\n          hint: selectHint\n        });\n      }\n\n      if (completer.name == 'wikidata') {\n        //Do not replace the prefix \n        var prefix = token.string.split(':')[0];\n        startChar = token.start + prefix.length + 1;\n      } else {\n        startChar = token.start;\n      }\n    } else {\n      for (var i = 0; i < suggestions.length; i++) {\n        var suggestedString = suggestions[i];\n\n        if (completer.postProcessToken) {\n          suggestedString = completer.postProcessToken(token, suggestedString);\n        }\n\n        hintList.push({\n          text: suggestedString,\n          displayText: suggestedString,\n          hint: selectHint\n        });\n      }\n\n      startChar = token.start;\n    }\n\n    var cur = yashe.getCursor();\n    var returnObj = {\n      completionToken: token.string,\n      list: hintList,\n      from: {\n        line: cur.line,\n        ch: startChar\n      },\n      to: {\n        line: cur.line,\n        ch: token.end\n      }\n    }; //if we have some autocompletion handlers specified, add these these to the object. Codemirror will take care of firing these\n\n    if (completer.callbacks) {\n      for (var callbackName in completer.callbacks) {\n        if (completer.callbacks[callbackName]) {\n          YASHE.on(returnObj, callbackName, completer.callbacks[callbackName]);\n        }\n      }\n    }\n\n    return returnObj;\n  };\n\n  return {\n    init: initCompleter,\n    completers: completers,\n    notifications: {\n      getEl: function (completer) {\n        return $(completionNotifications[completer.name]);\n      },\n      show: function (yashe, completer) {\n        //only draw when the user needs to use a keypress to summon autocompletions\n        if (!completer.autoshow) {\n          if (!completionNotifications[completer.name]) completionNotifications[completer.name] = $(\"<div class='completionNotification'></div>\");\n          completionNotifications[completer.name].show().text(\"Press CTRL - <spacebar> to autocomplete\").appendTo($(yashe.getWrapperElement()));\n        }\n      },\n      hide: function (yashe, completer) {\n        if (completionNotifications[completer.name]) {\n          completionNotifications[completer.name].hide();\n        }\n      }\n    },\n    autoComplete: autoComplete,\n    getTrie: function (completer) {\n      return typeof completer == \"string\" ? tries[completer] : tries[completer.name];\n    }\n  };\n};\n/**\n * function which fires after the user selects a completion. this function checks whether we actually need to store this one (if completion is same as current token, don't do anything)\n */\n\n\nvar selectHint = function (yashe, data, completion) {\n  if (completion.text != yashe.getTokenAt(yashe.getCursor()).string) {\n    yashe.replaceRange(completion.text, data.from, data.to);\n  }\n}; //\n//module.exports = {\n//\tpreprocessPrefixTokenForCompletion: preprocessPrefixTokenForCompletion,\n//\tpostprocessResourceTokenForCompletion: postprocessResourceTokenForCompletion,\n//\tpreprocessResourceTokenForCompletion: preprocessResourceTokenForCompletion,\n//\tshowCompletionNotification: showCompletionNotification,\n//\thideCompletionNotification: hideCompletionNotification,\n//\tautoComplete: autoComplete,\n//\tautocompleteVariables: autocompleteVariables,\n//\tfetchFromPrefixCc: fetchFromPrefixCc,\n//\tfetchFromLov: fetchFromLov,\n////\tstoreBulkCompletions: storeBulkCompletions,\n//\tloadBulkCompletions: loadBulkCompletions,\n//};","map":null,"metadata":{},"sourceType":"script"}