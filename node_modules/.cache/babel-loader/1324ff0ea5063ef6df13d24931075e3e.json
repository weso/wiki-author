{"ast":null,"code":"\"use strict\";\n/*\n  jQuery deparam is an extraction of the deparam method from Ben Alman's jQuery BBQ\n  http://benalman.com/projects/jquery-bbq-plugin/\n*/\n\nvar $ = require(\"jquery\");\n\n$.deparam = function (params, coerce) {\n  var obj = {},\n      coerce_types = {\n    true: !0,\n    false: !1,\n    null: null\n  }; // Iterate over all name=value pairs.\n\n  $.each(params.replace(/\\+/g, \" \").split(\"&\"), function (j, v) {\n    var param = v.split(\"=\"),\n        key = decodeURIComponent(param[0]),\n        val,\n        cur = obj,\n        i = 0,\n        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it\n    // into its component parts.\n    keys = key.split(\"][\"),\n        keys_last = keys.length - 1; // If the first keys part contains [ and the last ends with ], then []\n    // are correctly balanced.\n\n    if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keys_last])) {\n      // Remove the trailing ] from the last keys part.\n      keys[keys_last] = keys[keys_last].replace(/\\]$/, \"\"); // Split first keys part into two parts on the [ and add them back onto\n      // the beginning of the keys array.\n\n      keys = keys.shift().split(\"[\").concat(keys);\n      keys_last = keys.length - 1;\n    } else {\n      // Basic 'foo' style key.\n      keys_last = 0;\n    } // Are we dealing with a name=value pair, or just a name?\n\n\n    if (param.length === 2) {\n      val = decodeURIComponent(param[1]); // Coerce values.\n\n      if (coerce) {\n        val = val && !isNaN(val) ? +val // number\n        : val === \"undefined\" ? undefined // undefined\n        : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n        : val; // string\n      }\n\n      if (keys_last) {\n        // Complex key, build deep object structure based on a few rules:\n        // * The 'cur' pointer starts at the object top-level.\n        // * [] = array push (n is set to array length), [n] = array if n is\n        //   numeric, otherwise object.\n        // * If at the last keys part, set the value.\n        // * For each keys part, if the current level is undefined create an\n        //   object or array based on the type of the next keys part.\n        // * Move the 'cur' pointer to the next level.\n        // * Rinse & repeat.\n        for (; i <= keys_last; i++) {\n          key = keys[i] === \"\" ? cur.length : keys[i];\n          cur = cur[key] = i < keys_last ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : []) : val;\n        }\n      } else {\n        // Simple key, even simpler rules, since only scalars and shallow\n        // arrays are allowed.\n        if ($.isArray(obj[key])) {\n          // val is already an array, so push on the next value.\n          obj[key].push(val);\n        } else if (obj[key] !== undefined) {\n          // val isn't an array, but since a second value has been specified,\n          // convert val into an array.\n          obj[key] = [obj[key], val];\n        } else {\n          // val is a scalar.\n          obj[key] = val;\n        }\n      }\n    } else if (key) {\n      // No value was defined, so set something meaningful.\n      obj[key] = coerce ? undefined : \"\";\n    }\n  });\n  return obj;\n};","map":null,"metadata":{},"sourceType":"script"}