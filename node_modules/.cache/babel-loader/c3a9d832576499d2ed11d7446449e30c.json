{"ast":null,"code":"\"use strict\";\n\nvar $ = require(\"jquery\"),\n    yutils = require(\"yasgui-utils\"),\n    imgs = require(\"./imgs.js\");\n\nvar checkSyntax = function (yashe) {\n  let defPrefixes = [];\n  let prefixes = [];\n  let shapes = [];\n  let shapeRefs = [];\n  yashe.queryValid = true;\n  yashe.clearGutter(\"gutterErrorBar\");\n  var state = null;\n  let openTokensCounter = 0;\n  let closeTokensCounter = 0;\n\n  for (var l = 0; l < yashe.lineCount(); ++l) {\n    var precise = false;\n\n    if (!yashe.prevQueryValid) {\n      // we don't want cached information in this case, otherwise the\n      // previous error sign might still show up,\n      // even though the syntax error might be gone already\n      precise = true;\n    }\n\n    var token = yashe.getTokenAt({\n      line: l,\n      ch: yashe.getLine(l).length\n    }, precise);\n    var state = token.state;\n\n    if (state.OK == false) {\n      if (!yashe.options.syntaxErrorCheck) {\n        //the library we use already marks everything as being an error. Overwrite this class attribute.\n        $(yashe.getWrapperElement()).find(\".sp-error\").css(\"color\", \"black\"); //we don't want to gutter error, so return\n\n        return;\n      }\n\n      var warningEl = yutils.svg.getElement(imgs.warning);\n\n      if (state.errorMsg) {\n        require(\"./tooltipUtils.js\").grammarTootlip(yashe, warningEl, function () {\n          return $(\"<div/>\").text(token.state.errorMsg).html();\n        });\n      } else if (state.possibleCurrent && state.possibleCurrent.length > 0) {\n        //\t\t\t\twarningEl.style.zIndex = \"99999999\";\n        require(\"./tooltipUtils.js\").grammarTootlip(yashe, warningEl, function () {\n          var expectedEncoded = [];\n          state.possibleCurrent.forEach(function (expected) {\n            expectedEncoded.push(\"<strong style='text-decoration:underline'>\" + $(\"<div/>\").text(expected).html() + \"</strong>\");\n          });\n          return \"This line is invalid. Expected: \" + expectedEncoded.join(\", \");\n        });\n      }\n\n      warningEl.style.marginTop = \"2px\";\n      warningEl.style.marginLeft = \"2px\";\n      warningEl.className = \"parseErrorIcon\";\n      yashe.setGutterMarker(l, \"gutterErrorBar\", warningEl);\n      yashe.queryValid = false;\n      return false;\n    } //This is only necessary to verify the if the last '}' is missing  (See #104)\n\n\n    let lineTokens = yashe.getLineTokens(l); //Get all the defined prefixes and all the used prefixes\n    //Get all the defined shapes and all the used shapes\n\n    for (let t in lineTokens) {\n      let token = lineTokens[t];\n\n      if (token.string == '{') {\n        openTokensCounter++;\n      }\n\n      if (token.string == '}') {\n        closeTokensCounter++;\n      }\n\n      if (token.type == 'string-2' || token.type == 'constraint') {\n        prefixes.push({\n          alias: token.string.split(\":\")[0] + ':',\n          line: l\n        });\n      }\n\n      if (token.type == 'valueSet') {\n        if (token.string.includes(\":\")) {\n          prefixes.push({\n            alias: token.string.split(\":\")[0] + ':',\n            line: l\n          });\n        }\n      }\n\n      if (token.type == 'prefixDelcAlias') {\n        defPrefixes.push(token.string);\n      }\n\n      if (token.type == 'shape') {\n        shapes.push(token.string);\n      }\n\n      if (token.type == 'shapeRef') {\n        shapeRefs.push({\n          ref: token.string.slice(1, token.string.length),\n          line: l\n        });\n      } //Necesary when the ShapeRef is \"@:\"\n\n\n      if (token.string == '@') {\n        shapeRefs.push({\n          ref: '@:',\n          line: l\n        });\n      }\n    }\n  } //Check if the Prefixes are defined\n\n\n  for (let p in prefixes) {\n    let err = true;\n\n    for (let d in defPrefixes) {\n      if (defPrefixes[d] == prefixes[p].alias) err = false;\n    }\n\n    if (err) {\n      setError(prefixes[p].line, \"Prefix '\" + prefixes[p].alias + \"' is not defined\");\n      yashe.queryValid = false;\n      return false;\n    }\n  } //Check if the ShapeRefs are defined\n\n\n  for (let r in shapeRefs) {\n    let err = true;\n\n    for (let s in shapes) {\n      if (shapes[s] == shapeRefs[r].ref) err = false;\n    }\n\n    if (err) {\n      setError(shapeRefs[r].line, \"Shape '\" + shapeRefs[r].ref + \"' is not defined\");\n      yashe.queryValid = false;\n      return false;\n    }\n  } // Is last '}' missing?  (See #104)\n\n\n  if (openTokensCounter != closeTokensCounter) {\n    setError(l, \"This line is invalid. Expected: '}'\");\n    yashe.queryValid = false;\n    return false;\n  }\n\n  yashe.prevQueryValid = yashe.queryValid;\n  return true;\n};\n\nvar setError = function (line, errMsg) {\n  var warningEl = yutils.svg.getElement(imgs.warning);\n\n  require(\"./tooltipUtils.js\").grammarTootlip(yashe, warningEl, function () {\n    return errMsg;\n  });\n\n  warningEl.style.marginTop = \"2px\";\n  warningEl.style.marginLeft = \"2px\";\n  warningEl.className = \"parseErrorIcon\";\n  yashe.setGutterMarker(line, \"gutterErrorBar\", warningEl);\n};\n\nmodule.exports = {\n  checkSyntax: checkSyntax\n};","map":null,"metadata":{},"sourceType":"script"}