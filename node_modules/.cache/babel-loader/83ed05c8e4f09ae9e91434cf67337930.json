{"ast":null,"code":"var CodeMirror = require(\"codemirror\"),\n    tokenUtils = require(\"./tokenUtils.js\");\n\n\"use strict\";\n\nvar lookFor = \"PREFIX \";\nmodule.exports = {\n  findFirstPrefixLine: function (cm) {\n    var lastLine = cm.lastLine();\n\n    for (var i = 0; i <= lastLine; ++i) {\n      if (findFirstPrefix(cm, i) >= 0) {\n        return i;\n      }\n    }\n  }\n};\n\nfunction findFirstPrefix(cm, line, ch, lineText) {\n  if (!ch) ch = 0;\n  if (!lineText) lineText = cm.getLine(line);\n  lineText = lineText.toUpperCase();\n\n  for (var at = ch, pass = 0;;) {\n    var found = lineText.indexOf(lookFor, at);\n\n    if (found == -1) {\n      //no prefix on this line\n      if (pass == 1) break;\n      pass = 1;\n      at = lineText.length;\n      continue;\n    }\n\n    if (pass == 1 && found < ch) break;\n    var tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n    if (!/^(comment|string)/.test(tokenType)) return found + 1;\n    if (!/(comment)/.test(tokenType)) break; //Could not find a prefix, no use looping any further. Probably invalid query\n\n    if (at === pass) break;\n  }\n}\n\nCodeMirror.registerHelper(\"fold\", \"prefix\", function (cm, start) {\n  if (!start) {\n    start = {\n      line: 0,\n      ch: 0\n    };\n  }\n\n  var line = start.line,\n      lineText = cm.getLine(line);\n  var startCh, tokenType;\n\n  function hasPreviousPrefix() {\n    var hasPreviousPrefix = false;\n\n    for (var i = line - 1; i >= 0; i--) {\n      if (cm.getLine(i).toUpperCase().indexOf(lookFor) >= 0) {\n        hasPreviousPrefix = true;\n        break;\n      }\n    }\n\n    return hasPreviousPrefix;\n  }\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var getLastPrefixPos = function (line, ch) {\n    var prefixKeywordToken = cm.getTokenAt(CodeMirror.Pos(line, ch + 1));\n    if (!prefixKeywordToken || prefixKeywordToken.type != \"keyword\") return -1;\n    var prefixShortname = tokenUtils.getNextNonWsToken(cm, line, prefixKeywordToken.end + 1);\n    if (!prefixShortname || prefixShortname.type != \"prefixDelcAlias\") return -1; //missing prefix alias\n\n    var prefixUri = tokenUtils.getNextNonWsToken(cm, line, prefixShortname.end + 1);\n    if (!prefixUri || prefixUri.type != \"prefixDelcIRI\") return -1; //missing prefix iri\n\n    return prefixUri.end;\n  }; //only use opening prefix declaration\n\n\n  if (hasPreviousPrefix()) return;\n  var prefixStart = findFirstPrefix(cm, line, start.ch, lineText);\n  if (prefixStart == null) return;\n  var stopAt = \"{\"; //if this char is there, we won't have a chance of finding more prefixes\n\n  var stopAtNextLine = false;\n  var count = 1,\n      lastLine = cm.lastLine(),\n      end,\n      endCh;\n  var prefixEndChar = getLastPrefixPos(line, prefixStart);\n  var prefixEndLine = line;\n\n  outer: for (var i = line; i <= lastLine; ++i) {\n    if (stopAtNextLine) break;\n    var text = cm.getLine(i),\n        pos = i == line ? prefixStart + 1 : 0;\n\n    for (;;) {\n      if (!stopAtNextLine && text.indexOf(stopAt) >= 0) stopAtNextLine = true;\n      var nextPrefixDeclaration = text.toUpperCase().indexOf(lookFor, pos);\n\n      if (nextPrefixDeclaration >= 0) {\n        if ((endCh = getLastPrefixPos(i, nextPrefixDeclaration)) > 0) {\n          prefixEndChar = endCh;\n          prefixEndLine = i;\n          pos = prefixEndChar;\n        }\n\n        pos++;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return {\n    from: CodeMirror.Pos(line, prefixStart + lookFor.length),\n    to: CodeMirror.Pos(prefixEndLine, prefixEndChar)\n  };\n});","map":null,"metadata":{},"sourceType":"script"}