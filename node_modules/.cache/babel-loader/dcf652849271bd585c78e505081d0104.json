{"ast":null,"code":"'use strict'; // make sure any console statements\n\nwindow.console = window.console || {\n  log: function () {}\n};\n/**\n * Load libraries and utils\n */\n\nconst $ = require('jquery');\n\nconst codeMirror = require('codemirror');\n\nconst utils = require('./utils/baseUtils.js');\n\nconst yutils = require('yasgui-utils');\n\nconst prefixUtils = require('./utils/prefixUtils.js');\n\nconst tokenUtils = require('./utils/tokenUtils.js');\n\nconst syntaxUtils = require('./utils/syntaxUtils.js');\n\nconst tooltipUtils = require('./utils/tooltipUtils.js');\n\nconst formatUtils = require('./utils/formatUtils.js');\n\nconst buttonsUtils = require('./utils/buttonsUtils.js');\n\nconst prefixFold = require('./utils/prefixFold.js');\n\nconst autocompletersBase = require('./autocompleters/autocompleterBase.js');\n\nconst Clipboard = require('clipboard');\n\nrequire('../lib/deparam.js');\n\nrequire('codemirror/addon/fold/foldcode.js');\n\nrequire('codemirror/addon/fold/foldgutter.js');\n\nrequire('codemirror/addon/fold/xml-fold.js');\n\nrequire('codemirror/addon/fold/brace-fold.js');\n\nrequire('codemirror/addon/hint/show-hint.js');\n\nrequire('codemirror/addon/search/searchcursor.js');\n\nrequire('codemirror/addon/edit/matchbrackets.js');\n\nrequire('codemirror/addon/runmode/runmode.js');\n\nrequire('codemirror/addon/display/fullscreen.js');\n\nrequire('../lib/grammar/tokenizer.js');\n/**\n * Main YASHE constructor.\n * Pass a DOM element as argument to append the editor to,\n * and (optionally) pass along config settings\n * (see the YASHE.defaults object below,\n * as well as the regular codeMirror documentation,\n * for more information on configurability)\n *\n * @constructor\n * @param {DOM-Element} parent element to append editor to.\n * @param {object} config\n * @class YASHE\n * @return {doc} YASHE document\n */\n\n\nconst root = module.exports = function (parent, config) {\n  const rootEl = $('<div>', {\n    class: 'yashe'\n  }).appendTo($(parent));\n  config = extendConfig(config);\n  const yashe = extendCmInstance(codeMirror(rootEl[0], config));\n  postProcessCmElement(yashe);\n  return yashe;\n};\n/**\n * Extend config object, which we will pass on to the CM constructor later on.\n * Need this, to make sure our own 'onBlur' etc events do not get overwritten by\n * people who add their own onblur events to the config Additionally, need this\n * to include the CM defaults ourselves. codeMirror has a method for including\n * defaults, but we can't rely on that one: it assumes flat config object, where\n * we have nested objects (e.g. the persistency option)\n *\n * @private\n * @param {object} config\n * @return {object} YASHE config\n */\n\n\nconst extendConfig = function (config) {\n  const extendedConfig = $.extend(true, {}, root.defaults, config); // I know, codemirror deals with  default options as well.\n  // However, it does not do this recursively (i.e. the persistency option)\n\n  return extendedConfig;\n};\n/**\n * Add extra functions to the CM document (i.e. the codemirror instantiated\n * object)\n *\n * @private\n * @param {object} yashe\n * @return {doc} YASHE document\n */\n\n\nconst extendCmInstance = function (yashe) {\n  // instantiate autocompleters\n  yashe.autocompleters = autocompletersBase(root, yashe);\n\n  if (yashe.options.autocompleters) {\n    yashe.options.autocompleters.forEach(function (name) {\n      if (root.Autocompleters[name]) {\n        yashe.autocompleters.init(name, root.Autocompleters[name]);\n      }\n    });\n  }\n  /**\n   * Returns the entire token by the cursor\n   * @return {object} token\n  */\n\n\n  yashe.getCompleteToken = function () {\n    return tokenUtils.getCompleteToken(yashe);\n  };\n  /**\n   * Returns the previous token that is not a WS token\n   * @param {onject} line\n   * @param {onject} token\n   * @return {object} token\n  */\n\n\n  yashe.getPreviousNonWsToken = function (line, token) {\n    return tokenUtils.getPreviousNonWsToken(yashe, line, token);\n  };\n  /**\n   * Returns the next token that is not a WS token\n   * @param {onject} lineNumber\n   * @param {onject} charNumber\n   * @return {object} token\n  */\n\n\n  yashe.getNextNonWsToken = function (lineNumber, charNumber) {\n    return tokenUtils.getNextNonWsToken(yashe, lineNumber, charNumber);\n  };\n  /**\n   * Colapse all prefixes of the ShEx documment\n   * @param {boolean} collapse\n  */\n\n\n  yashe.collapsePrefixes = function (collapse) {\n    if (collapse === undefined) collapse = true;\n    yashe.foldCode(prefixFold.findFirstPrefixLine(yashe), root.fold.prefix, collapse ? \"fold\" : \"unfold\");\n  };\n  /**\n   * Returns true if yashe has syntax errors. False otherwise\n   * @param {object} yashe\n   * @return {boolean} \n   */\n\n\n  yashe.hasErrors = function () {\n    return !syntaxUtils.checkSyntax(yashe);\n  };\n  /**\n   * Fetch defined prefixes\n   * @method doc.getDefinedPrefixes\n   * @return {object} prefixes\n   */\n\n\n  yashe.getDefinedPrefixes = function () {\n    return prefixUtils.getDefinedPrefixes(yashe);\n  };\n  /**\n   * Add prefixes to the ShEx documment\n   * @param {string|list} prefixes String if you want to add just one\n   * List in other case\n   */\n\n\n  yashe.addPrefixes = function (prefixes) {\n    prefixUtils.addPrefixes(yashe, prefixes);\n  };\n  /**\n   * Remove prefixes from the ShEx documment\n   * @param {list} prefixes\n   */\n\n\n  yashe.removePrefixes = function (prefixes) {\n    prefixUtils.removePrefixes(yashe, prefixes);\n  };\n  /**\n   * Allows to enable or disable Systax error checker\n   * @param {boolean} isEnabled\n   */\n\n\n  yashe.setCheckSyntaxErrors = function (isEnabled) {\n    yashe.options.syntaxErrorCheck = isEnabled;\n    checkSyntax(yashe);\n  };\n  /**\n   * Enables the autocompleter that you pass by param\n   * @param {string} name The name of the autocompleter\n   */\n\n\n  yashe.enableCompleter = function (name) {\n    addCompleterToSettings(yashe.options, name);\n\n    if (root.Autocompleters[name]) {\n      yashe.autocompleters.init(name, root.Autocompleters[name]);\n    }\n  };\n  /**\n   * Disables the autocompleter that you pass by param\n   * @param {string} name The name of the autocompleter\n   */\n\n\n  yashe.disableCompleter = function (name) {\n    removeCompleterFromSettings(yashe.options, name);\n  };\n\n  return yashe;\n};\n/**\n * Creates autocompleters list in the settigns if it does not exit\n * Add the autocompleter that you pass by param to the atucompleters settigns.\n * @param {object} settings YASHE settings\n * @param {string} name Autocompleter name\n */\n\n\nconst addCompleterToSettings = function (settings, name) {\n  if (!settings.autocompleters) settings.autocompleters = [];\n  settings.autocompleters.push(name);\n};\n/**\n * Remove the autocompleter that you pass by param from the\n * autocompleters settigns.\n * @param {object} settings YASHE settings\n * @param {string} name Autocompleter name\n */\n\n\nconst removeCompleterFromSettings = function (settings, name) {\n  if (typeof settings.autocompleters == 'object') {\n    const index = $.inArray(name, settings.autocompleters);\n\n    if (index >= 0) {\n      settings.autocompleters.splice(index, 1); // just in case. suppose 1 completer is listed twice\n\n      removeCompleterFromSettings(settings, name);\n    }\n  }\n};\n/**\n * Add extra funcionalitys to YASHE\n * @param {object} yashe\n */\n\n\nconst postProcessCmElement = function (yashe) {\n  buttonsUtils.drawButtons(yashe);\n  setFontSize(yashe); // Trigger of the button with id='copy'\n  // Copies the contents of the editor in the clipboard\n\n  new Clipboard('#copyBtn', {\n    text: function (trigger) {\n      return yashe.getValue();\n    }\n  });\n  /**\n   * Set doc value if option storeShape is activated\n   */\n\n  const storageId = utils.getPersistencyId(yashe, yashe.options.persistent);\n\n  if (storageId) {\n    const valueFromStorage = yutils.storage.get(storageId);\n    if (valueFromStorage) yashe.setValue(valueFromStorage);\n  } // --- Event handlers ----\n\n  /**\n   * Fires whenever the editor is unfocused.\n   * In this case, YASHE stores it content\n   */\n\n\n  yashe.on('blur', function (yashe) {\n    root.storeContent(yashe);\n  });\n  /**\n   * Fires every time the content of the editor is changed.\n   * In this case, YASHE checks the sintax\n   */\n\n  yashe.on('change', function (yashe) {\n    checkSyntax(yashe);\n  }); //Needed\n  //Without this, there is a bug \n\n  yashe.on('changes', function (yashe) {\n    checkSyntax(yashe);\n  });\n  /**\n   * Fires when the editor is scrolled.\n   * In this case, YASHE removes Wikidata Tooltip\n   */\n\n  yashe.on('scroll', function () {\n    tooltipUtils.removeWikiToolTip();\n  });\n  /**\n   * Wikidata Tooltip Listener\n   */\n\n  root.on(yashe.getWrapperElement(), 'mouseover', tooltipUtils.debounce(function (e) {\n    if (yashe.options.showTooltip) {\n      tooltipUtils.removeWikiToolTip();\n      tooltipUtils.triggerTooltip(yashe, e);\n    }\n  }, 300)); // on first load, check as well\n  // (our stored or default query might be incorrect)\n\n  checkSyntax(yashe);\n  yashe.collapsePrefixes(yashe.options.collapsePrefixesOnLoad);\n};\n/**\n * Set font size of the editor\n * @param {object} yashe\n */\n\n\nconst setFontSize = function (yashe) {\n  $('.CodeMirror').css('font-size', yashe.options.fontSize);\n};\n/**\n * Stores YASHE content\n * @param {object} yashe\n */\n\n\nroot.storeContent = function (yashe) {\n  const storageId = utils.getPersistencyId(yashe, yashe.options.persistent);\n\n  if (storageId) {\n    yutils.storage.set(storageId, yashe.getValue(), 'month', yashe.options.onQuotaExceeded);\n  }\n};\n/**\n * Checks YASHE content syntax\n * @param {object} yashe\n * @return {string} Check result\n */\n\n\nconst checkSyntax = function (yashe) {\n  return syntaxUtils.checkSyntax(yashe);\n}; // ---- Static Utils -----\n// first take all codeMirror references and store them in the YASHE object\n\n\n$.extend(root, codeMirror); // add registrar for autocompleters\n\nroot.Autocompleters = {};\n\nroot.registerAutocompleter = function (name, constructor) {\n  root.Autocompleters[name] = constructor;\n  addCompleterToSettings(root.defaults, name);\n};\n\nroot.autoComplete = function (yashe) {\n  // this function gets called when pressing the keyboard shortcut.\n  // I.e., autoShow = false\n  yashe.autocompleters.autoComplete(false);\n}; // include the autocompleters we provide out-of-the-box\n\n\nroot.registerAutocompleter('wikidata', require('./autocompleters/wikidata.js'));\nroot.registerAutocompleter('prefixDefinition', require('./autocompleters/prefixDefinition.js'));\nroot.registerAutocompleter('prefixesAndKeywords', require('./autocompleters/prefixesAndKeywords.js'));\n/**\n * Initialize YASHE from an existing text area (see http://codemirror.net/doc/manual.html#fromTextArea for more info)\n  *\n * @method YASHE.fromTextArea\n * @param {DOM-element} textAreaEl\n * @param {object} config\n * @return {doc} YASHE document\n */\n\nroot.fromTextArea = function (textAreaEl, config) {\n  config = extendConfig(config); // add yashe div as parent (needed for styles to be manageable and scoped).\n  // In this case, I -also- put it as parent el of the text area.\n  // This is wrapped in a div now\n\n  $('<div>', {\n    class: 'yashe'\n  }).insertBefore($(textAreaEl)).append($(textAreaEl));\n  const yashe = extendCmInstance(codeMirror.fromTextArea(textAreaEl, config));\n  postProcessCmElement(yashe);\n  return yashe;\n}; // ---- Format utils -----\n\n/**\n * Comment or uncomment current/selected line(s)\n * @param {object} yashe\n */\n\n\nroot.commentLines = function (yashe) {\n  formatUtils.commentLines(yashe);\n};\n/**\n * Copy line up\n * @param {object} yashe\n */\n\n\nroot.copyLineUp = function (yashe) {\n  formatUtils.copyLineUp(yashe);\n};\n/**\n * Copy line down\n * @param {object} yashe\n */\n\n\nroot.copyLineDown = function (yashe) {\n  formatUtils.copyLineDown(yashe);\n};\n/**\n * Auto-format/indent selected lines\n * @param {object} yashe\n */\n\n\nroot.doAutoFormat = function (yashe) {\n  formatUtils.doAutoFormat(yashe);\n};\n\nrequire('./config/defaults.js');\n\nroot.$ = $;\nroot.version = {\n  'codeMirror': codeMirror.version,\n  'YASHE': require('../package.json').version,\n  'jquery': $.fn.jquery,\n  'yasgui-utils': yutils.version\n};\n/* var settings = {\n  \"async\": true,\n  \"crossDomain\": true,\n  \"url\": \"https://www.mediawiki.org/w/api.php?action=query&meta=tokens&format=json\",\n  \"method\": \"GET\",\n  \"dataType\": 'jsonp',\n}\n\n$.ajax(settings).done(function (response) {\n  console.log(response);\n});\n\n\nvar Bloodhound = require('bloodhound-js');\n\n // Defining the local dataset\n   var engine = new Bloodhound({\n  local: ['dog', 'pig', 'moose'],\n  queryTokenizer: Bloodhound.tokenizers.whitespace,\n  datumTokenizer: Bloodhound.tokenizers.whitespace\n});\n\n\n\n\nvar typeahead = document.getElementsByClassName(\"typeahead\")[0];\ntypeahead.addEventListener(\"keyup\",function(e){\n var aux = e.target.value\n\n  var promise = engine.initialize();\n\n  promise.then(function() {\n    \n  engine.search(\n    aux,\n    function(d) {\n      console.log(d);\n    },\n    function(d) {\n      console.log(d);\n    }\n  );\n  \n});\n\n\n})\n\n */","map":null,"metadata":{},"sourceType":"script"}