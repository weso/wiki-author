{"ast":null,"code":"var CodeMirror = require(\"codemirror\");\n\nconst $ = require('jquery');\n\n\"use strict\";\n\nvar commentLines = function (yashe) {\n  var startLine = yashe.getCursor(true).line;\n  var endLine = yashe.getCursor(false).line;\n  var min = Math.min(startLine, endLine);\n  var max = Math.max(startLine, endLine); // if all lines start with #, remove this char. Otherwise add this char\n\n  var linesAreCommented = true;\n\n  for (var i = min; i <= max; i++) {\n    var line = yashe.getLine(i);\n\n    if (line.length == 0 || line.substring(0, 1) != \"#\") {\n      linesAreCommented = false;\n      break;\n    }\n  }\n\n  for (var i = min; i <= max; i++) {\n    if (linesAreCommented) {\n      // lines are commented, so remove comments\n      yashe.replaceRange(\"\", {\n        line: i,\n        ch: 0\n      }, {\n        line: i,\n        ch: 1\n      });\n    } else {\n      // Not all lines are commented, so add comments\n      yashe.replaceRange(\"#\", {\n        line: i,\n        ch: 0\n      });\n    }\n  }\n};\n\nvar copyLineUp = function (yashe) {\n  var cursor = yashe.getCursor();\n  var lineCount = yashe.lineCount(); // First create new empty line at end of text\n\n  yashe.replaceRange(\"\\n\", {\n    line: lineCount - 1,\n    ch: yashe.getLine(lineCount - 1).length\n  }); // Copy all lines to their next line\n\n  for (var i = lineCount; i > cursor.line; i--) {\n    var line = yashe.getLine(i - 1);\n    yashe.replaceRange(line, {\n      line: i,\n      ch: 0\n    }, {\n      line: i,\n      ch: yashe.getLine(i).length\n    });\n  }\n};\n\nvar copyLineDown = function (yashe) {\n  copyLineUp(yashe); // Make sure cursor goes one down (we are copying downwards)\n\n  var cursor = yashe.getCursor();\n  cursor.line++;\n  yashe.setCursor(cursor);\n};\n\nvar doAutoFormat = function (yashe) {\n  if (!yashe.somethingSelected()) yashe.execCommand(\"selectAll\");\n  var to = {\n    line: yashe.getCursor(false).line,\n    ch: yashe.getSelection().length\n  };\n  autoFormatRange(yashe, yashe.getCursor(true), to);\n};\n\nvar autoFormatRange = function (yashe, from, to) {\n  var absStart = yashe.indexFromPos(from);\n  var absEnd = yashe.indexFromPos(to); // Insert additional line breaks where necessary according to the\n  // mode's syntax\n\n  var res = autoFormatLineBreaks(yashe.getValue(), absStart, absEnd); // Replace and auto-indent the range\n\n  yashe.operation(function () {\n    yashe.replaceRange(res, from, to);\n    var startLine = yashe.posFromIndex(absStart).line;\n    var endLine = yashe.posFromIndex(absStart + res.length).line;\n\n    for (var i = startLine; i <= endLine; i++) {\n      yashe.indentLine(i, \"smart\");\n    }\n  });\n};\n\nvar autoFormatLineBreaks = function (text, start, end) {\n  text = text.substring(start, end);\n  var breakAfterArray = [[\"keyword\", \"ws\", \"prefixed\", \"ws\", \"uri\"], // i.e. prefix declaration\n  [\"keyword\", \"ws\", \"uri\"] // i.e. base\n  ];\n  var breakAfterCharacters = [\"{\", \".\", \";\"];\n  var breakBeforeCharacters = [\"}\"];\n\n  var getBreakType = function (stringVal, type) {\n    for (var i = 0; i < breakAfterArray.length; i++) {\n      if (stackTrace.valueOf().toString() == breakAfterArray[i].valueOf().toString()) {\n        return 1;\n      }\n    }\n\n    for (var i = 0; i < breakAfterCharacters.length; i++) {\n      if (stringVal == breakAfterCharacters[i]) {\n        return 1;\n      }\n    }\n\n    for (var i = 0; i < breakBeforeCharacters.length; i++) {\n      // don't want to issue 'breakbefore' AND 'breakafter', so check\n      // current line\n      if ($.trim(currentLine) != \"\" && stringVal == breakBeforeCharacters[i]) {\n        return -1;\n      }\n    }\n\n    return 0;\n  };\n\n  var formattedQuery = \"\";\n  var currentLine = \"\";\n  var stackTrace = [];\n  CodeMirror.runMode(text, \"shex\", function (stringVal, type) {\n    stackTrace.push(type);\n    var breakType = getBreakType(stringVal, type);\n\n    if (breakType != 0) {\n      if (breakType == 1) {\n        formattedQuery += stringVal + \"\\n\";\n        currentLine = \"\";\n      } else {\n        // (-1)\n        formattedQuery += \"\\n\" + stringVal;\n        currentLine = stringVal;\n      }\n\n      stackTrace = [];\n    } else {\n      currentLine += stringVal;\n      formattedQuery += stringVal;\n    }\n\n    if (stackTrace.length == 1 && stackTrace[0] == \"sp-ws\") stackTrace = [];\n  });\n  return $.trim(formattedQuery.replace(/\\n\\s*\\n/g, \"\\n\"));\n};\n\nmodule.exports = {\n  commentLines: commentLines,\n  copyLineUp: copyLineUp,\n  copyLineDown: copyLineDown,\n  doAutoFormat: doAutoFormat\n};","map":null,"metadata":{},"sourceType":"script"}